\section{Mô hình biểu diễn tri thức} 

Mô hình Hệ luật dẫn dạng (F,R) cho kiến thức thu thập được thể hiện như sau:
\begin{itemize}
	\item \textbf{Facts (F)} = tập đỉnh bắt đầu (\texttt{start\_node}), đỉnh kết thúc (\texttt{end\_node}), và các cặp đỉnh cùng khoảng cách của nó trong đồ thị gọi là (\texttt{path}):
	\begin{itemize}
		\item \texttt{start\_node}
		\item \texttt{end\_node}
		\item \texttt{path\_1}, \texttt{path\_2}, \texttt{path\_3}, ...\texttt{path\_n}
	\end{itemize}
	
	với \texttt{path} là bộ các (\texttt{from\_node}, \texttt{to\_node}, \texttt{distance}).
	
	\item \textbf{Rules (R)}
	\begin{itemize}
		\item $\forall \texttt{i} \in \{\texttt{1,n}\}, \texttt{from\_node\_i}, \texttt{to\_node\_j} \in \texttt{path\_i}, \\ \texttt{adjacency\_list}[\texttt{from\_node\_i}]=\{ \texttt{to\_node\_j} | \texttt{from\_node\_j} = \texttt{from\_node\_i}, \forall \texttt{j} \in \{\texttt{1,n}\}\} \Rightarrow \texttt{adjacency\_list}$
		\item $\exists! \texttt{i} \in \texttt{n}, \min(\texttt{path\_i[distance]}) \Rightarrow \texttt{min\_path}$
	\end{itemize}
\end{itemize}


\textbf{Bài toán}

Cho đồ thị vô hướng, trọng số không âm. Tìm đường đi ngắn nhất giữa hai đỉnh lần lượt là đỉnh bắt đầu và đỉnh kết thúc.

\begin{itemize}
	\item \textbf{GT}: Danh sách các cặp đỉnh cùng trọng số (khoảng cách) của chúng, và hai đỉnh bắt đầu, kết thúc.
	
	Ví dụ: A B 3, B C 5,$\dots$; \texttt{start\_node} = A, \texttt{end\_node} = C
	\item \textbf{KL}: Trả về đường đi ngắn nhất, và khoảng cách của hai đỉnh đã cho. 
	
	Ví dụ: [A,B,C], 8
\end{itemize}

\begin{lstlisting}[language=Python, caption=Thuật toán Dijkstra]
def shortest_path(self, start_node, end_node):
	# Ban đầu, tất cả các đỉnh đều được coi như chưa được xét.
	unvisited_nodes = self.nodes.copy()
	
	# Khởi tạo một CTDL từ điển distance_from_start chứa các khoảng cách ban đầu (INFINITY) 
	# từ từng đỉnh đến đỉnh start_node. Từ điển này sẽ được cập nhật khi tìm đường ngắn nhất.
	distance_from_start = {
		node: (0 if node == start_node else INFINITY) for node in self.nodes
	}
	
	# Khởi tạo một CTDL từ điển previous_node chứa các đỉnh trước đó khi xét tới từng điểm
	# có đường đi ngắn nhất.
	previous_node = {node: None for node in self.nodes}
	
	# Xét tập các đỉnh chưa được xét
	while unvisited_nodes:
		# B1: Chọn một đỉnh trong danh sách đỉnh chưa xét mà có khoảng cách ngắn nhất trong 
		# từ điển [distance_from_start]
		current_node = min(
		unvisited_nodes, key=lambda node: distance_from_start[node]
		)
		
		# B2: Loại đỉnh đang xét khỏi danh sách đỉnh chưa xét
		unvisited_nodes.remove(current_node)
		
		# B3: Nếu đỉnh đang xét có khoảng cách tới đỉnh bắt đầu là INFINITY, 
		# nghĩa là hai đỉnh này không liên thông với nhau, quay lại B1
		if distance_from_start[current_node] == INFINITY:
			break
		
		# B4: Xét các đỉnh láng giềng của đỉnh đang xét, 
		# nếu tổng [khoảng cách của đỉnh láng giềng so với đỉnh đang xét] và [khoảng cách đỉnh bắt đầu so với đỉnh đang xét] bé hơn khoảng cách [đỉnh bắt đầu so với đỉnh láng giềng]
		# thì cập nhật khoảng cách ngắn nhất, và đỉnh trước đó của láng giềng là đỉnh đang xét
		for neighbor, distance in self.adjacency_list[current_node]:
			new_path = distance_from_start[current_node] + distance
			if new_path < distance_from_start[neighbor]:
				distance_from_start[neighbor] = new_path
				previous_node[neighbor] = current_node
		
		# B5: Nếu đỉnh đang xét là đỉnh kết thúc thì kết thúc bài toán.
		if current_node == end_node:
			break

	# Xây dựng CTDL hàng đợi hai đầu cho đường đi
	path = deque()
	
	# Thêm vào đầu hàng đợi lần lượt các đỉnh từ cuối đến đầu
	current_node = end_node
	while previous_node[current_node] is not None:
		path.appendleft(current_node)
		current_node = previous_node[current_node]
	path.appendleft(start_node)
	
	# Trả về đường đi ngắn nhất và khoảng cách cần tìm
	return path, distance_from_start[end_node]
\end{lstlisting}
